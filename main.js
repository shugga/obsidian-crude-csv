/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => CrudeCSVPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  templatePath: ""
};
var DEFAULT_CSV_CONTENT = "A,B\n0,0\n1,1";
var VIEW_TYPE_CSV = "crude-csv";
var FileNameModal = class extends import_obsidian.Modal {
  constructor(app, onSubmit) {
    super(app);
    this.onSubmit = onSubmit;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h2", { text: "Create New CSV File" });
    const inputContainer = contentEl.createEl("div", { cls: "modal-input-container" });
    inputContainer.createEl("label", { text: "File name:" });
    const input = inputContainer.createEl("input", {
      type: "text",
      placeholder: "Enter filename (without .csv extension)"
    });
    input.focus();
    const buttonContainer = contentEl.createEl("div", { cls: "modal-button-container" });
    const submitBtn = buttonContainer.createEl("button", {
      text: "Create",
      cls: "mod-cta"
    });
    const cancelBtn = buttonContainer.createEl("button", {
      text: "Cancel"
    });
    const submit = () => {
      const value = input.value.trim();
      if (value) {
        this.result = value;
        this.close();
        this.onSubmit(this.result);
      } else {
        new import_obsidian.Notice("Please enter a filename");
      }
    };
    submitBtn.addEventListener("click", submit);
    cancelBtn.addEventListener("click", () => this.close());
    input.addEventListener("keydown", (e) => {
      if (e.key === "Enter") {
        e.preventDefault();
        submit();
      } else if (e.key === "Escape") {
        this.close();
      }
    });
    contentEl.style.minWidth = "300px";
    inputContainer.style.marginBottom = "20px";
    input.style.width = "100%";
    input.style.marginTop = "5px";
    buttonContainer.style.display = "flex";
    buttonContainer.style.justifyContent = "flex-end";
    buttonContainer.style.gap = "10px";
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var CrudeCSVPlugin = class extends import_obsidian.Plugin {
  async onload() {
    await this.loadSettings();
    this.registerView(VIEW_TYPE_CSV, (leaf) => new CSVView(leaf));
    this.registerExtensions(["csv"], VIEW_TYPE_CSV);
    this.addRibbonIcon("table", "New CSV", () => {
      this.createNewCSV().catch(console.error);
    });
    this.addCommand({
      id: "create-new-csv",
      name: "New CSV",
      callback: () => this.createNewCSV().catch(console.error)
    });
    this.registerEvent(
      this.app.workspace.on("file-menu", (menu, file) => {
        if (file instanceof import_obsidian.TFolder) {
          menu.addItem((item) => {
            item.setTitle("New CSV").setIcon("table").onClick(async () => {
              await this.createNewCSV(file.path);
            });
          });
        }
      })
    );
    this.addSettingTab(new CrudeCSVSettingTab(this.app, this));
  }
  onunload() {
    this.app.workspace.detachLeavesOfType(VIEW_TYPE_CSV);
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  // Create a new CSV in the chosen folder (context menu) or vault root (ribbon/command)
  async createNewCSV(folderPath) {
    try {
      const targetFolder = await this.resolveTargetFolder(folderPath);
      if (!targetFolder) {
        new import_obsidian.Notice("Invalid folder. Could not create CSV.");
        return;
      }
      new FileNameModal(this.app, async (fileName) => {
        await this.createCSVWithName(fileName, targetFolder);
      }).open();
    } catch (err) {
      console.error("Failed to create CSV:", err);
      new import_obsidian.Notice("Failed to create CSV file.");
    }
  }
  async createCSVWithName(fileName, targetFolder) {
    try {
      const content = await this.getTemplateContent();
      const finalFileName = fileName.endsWith(".csv") ? fileName : `${fileName}.csv`;
      const tempFileName = `temp-csv-${Date.now()}.csv`;
      const tempFilePath = this.joinPath(targetFolder.path, tempFileName);
      const finalFilePath = this.joinPath(targetFolder.path, finalFileName);
      const existingFile = this.app.vault.getAbstractFileByPath(finalFilePath);
      if (existingFile) {
        new import_obsidian.Notice(`File "${finalFileName}" already exists.`);
        return;
      }
      const tempFile = await this.app.vault.create(tempFilePath, content);
      await this.app.vault.rename(tempFile, finalFilePath);
      const finalFile = this.app.vault.getAbstractFileByPath(finalFilePath);
      await this.app.workspace.getLeaf(true).openFile(finalFile);
      new import_obsidian.Notice(`Created ${finalFileName}`);
    } catch (err) {
      console.error("Failed to create CSV with custom name:", err);
      new import_obsidian.Notice("Failed to create CSV file.");
    }
  }
  async resolveTargetFolder(folderPath) {
    if (folderPath) {
      const af = this.app.vault.getAbstractFileByPath(folderPath);
      if (af instanceof import_obsidian.TFolder) return af;
      return null;
    }
    const active = this.app.workspace.getActiveFile();
    if ((active == null ? void 0 : active.parent) instanceof import_obsidian.TFolder) {
      return active.parent;
    }
    return this.app.vault.getRoot();
  }
  // Determine template content:
  // 1) Explicit settings.templatePath (file)
  // 2) Templater community plugin templates folder -> template.csv
  // 3) Core Templates plugin folder -> template.csv
  // 4) Fallback DEFAULT_CSV_CONTENT
  async getTemplateContent() {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j;
    if ((_a = this.settings.templatePath) == null ? void 0 : _a.trim()) {
      const file = this.app.vault.getAbstractFileByPath(this.settings.templatePath.trim());
      if (file instanceof import_obsidian.TFile) {
        try {
          return await this.app.vault.read(file);
        } catch (e) {
          console.log("Could not read custom templatePath file:", e);
        }
      } else {
        const maybe = this.joinPath(this.settings.templatePath.trim(), "template.csv");
        const f2 = this.app.vault.getAbstractFileByPath(maybe);
        if (f2 instanceof import_obsidian.TFile) {
          try {
            return await this.app.vault.read(f2);
          } catch (e) {
            console.log("Could not read custom template.csv (folder-based):", e);
          }
        }
      }
    }
    try {
      const templater = ((_c = (_b = this.app.plugins) == null ? void 0 : _b.getPlugin) == null ? void 0 : _c.call(_b, "templater-obsidian")) || ((_e = (_d = this.app.plugins) == null ? void 0 : _d.plugins) == null ? void 0 : _e["templater-obsidian"]);
      const tFolder = (_f = templater == null ? void 0 : templater.settings) == null ? void 0 : _f.templates_folder;
      if (tFolder) {
        const tFile = this.app.vault.getAbstractFileByPath(this.joinPath(tFolder, "template.csv"));
        if (tFile instanceof import_obsidian.TFile) {
          try {
            return await this.app.vault.read(tFile);
          } catch (e) {
            console.log("Could not read Templater template.csv:", e);
          }
        }
      }
    } catch (e) {
      console.log("Templater detection failed:", e);
    }
    try {
      const coreTemplates = (_h = (_g = this.app.internalPlugins) == null ? void 0 : _g.plugins) == null ? void 0 : _h.templates;
      if (coreTemplates == null ? void 0 : coreTemplates.enabled) {
        const folder = (_j = (_i = coreTemplates.instance) == null ? void 0 : _i.options) == null ? void 0 : _j.folder;
        if (folder) {
          const cFile = this.app.vault.getAbstractFileByPath(this.joinPath(folder, "template.csv"));
          if (cFile instanceof import_obsidian.TFile) {
            try {
              return await this.app.vault.read(cFile);
            } catch (e) {
              console.log("Could not read Core Templates template.csv:", e);
            }
          }
        }
      }
    } catch (e) {
      console.log("Core Templates detection failed:", e);
    }
    return DEFAULT_CSV_CONTENT;
  }
  joinPath(folder, name) {
    if (!folder || folder === "/") return name;
    return `${folder.replace(/\/+$/, "")}/${name.replace(/^\/+/, "")}`;
  }
};
var CSVView = class extends import_obsidian.TextFileView {
  constructor() {
    super(...arguments);
    this.tableData = [];
    this.tableEl = null;
  }
  getViewType() {
    return VIEW_TYPE_CSV;
  }
  getDisplayText() {
    var _a;
    return ((_a = this.file) == null ? void 0 : _a.name) || "CSV";
  }
  getIcon() {
    return "table";
  }
  // Called when Obsidian wants to save the file
  getViewData() {
    return this.tableData.map((row) => row.join(",")).join("\n");
  }
  // Called when Obsidian provides file content
  setViewData(data, _clear) {
    this.tableData = this.parseCSV(data);
    this.refresh();
  }
  clear() {
    this.tableData = [];
    if (this.tableEl) {
      this.tableEl.empty();
    }
  }
  async onOpen() {
    const toolbar = this.contentEl.createEl("div", { cls: "csv-toolbar" });
    const addRowBtn = toolbar.createEl("button", { text: "+R", cls: "csv-btn" });
    addRowBtn.addEventListener("click", () => this.addRow());
    const removeRowBtn = toolbar.createEl("button", { text: "-R", cls: "csv-btn" });
    removeRowBtn.addEventListener("click", () => this.removeRow());
    const addColBtn = toolbar.createEl("button", { text: "+C", cls: "csv-btn" });
    addColBtn.addEventListener("click", () => this.addColumn());
    const removeColBtn = toolbar.createEl("button", { text: "-C", cls: "csv-btn" });
    removeColBtn.addEventListener("click", () => this.removeColumn());
    const tableContainer = this.contentEl.createEl("div", { cls: "csv-table-container" });
    this.tableEl = tableContainer.createEl("table", { cls: "csv-table" });
  }
  async onClose() {
    this.contentEl.empty();
    this.tableEl = null;
  }
  parseCSV(data) {
    var _a;
    const trimmed = (_a = data == null ? void 0 : data.trim()) != null ? _a : "";
    if (!trimmed) return [["A", "B", "C"], ["0", "0", "0"], ["1", "1", "1"], ["2", "2", "2"]];
    const lines = trimmed.split("\n").filter((l) => l.trim().length > 0);
    const result = [];
    for (const line of lines) {
      const row = this.parseCSVLine(line);
      if (row.length > 0) result.push(row);
    }
    return result.length > 0 ? result : [["A", "B", "C"], ["0", "0", "0"], ["1", "1", "1"], ["2", "2", "2"]];
  }
  parseCSVLine(line) {
    const out = [];
    let cur = "";
    let inQuotes = false;
    for (let i = 0; i < line.length; i++) {
      const ch = line[i];
      const next = line[i + 1];
      if (ch === '"') {
        if (inQuotes && next === '"') {
          cur += '"';
          i++;
        } else {
          inQuotes = !inQuotes;
        }
      } else if (ch === "," && !inQuotes) {
        out.push(cur.trim());
        cur = "";
      } else {
        cur += ch;
      }
    }
    out.push(cur.trim());
    return out;
  }
  refresh() {
    if (!this.tableEl) return;
    this.tableEl.empty();
    this.tableData.forEach((row, r) => {
      const tr = this.tableEl.createEl("tr");
      const rowNumTd = tr.createEl("td", { cls: "csv-row-number" });
      rowNumTd.textContent = (r + 1).toString();
      row.forEach((cell, c) => {
        const td = tr.createEl("td");
        const input = td.createEl("input", { type: "text", value: cell });
        input.addEventListener("input", () => {
          this.tableData[r][c] = input.value;
          this.requestSave();
        });
        input.addEventListener("blur", () => {
          this.requestSave();
        });
      });
    });
  }
  addRow() {
    var _a, _b;
    if (this.tableData.length === 0) {
      this.tableData = [["A", "B", "C"]];
    } else {
      const cols = (_b = (_a = this.tableData[0]) == null ? void 0 : _a.length) != null ? _b : 1;
      this.tableData.push(new Array(cols).fill(""));
    }
    this.refresh();
    this.requestSave();
  }
  removeRow() {
    if (this.tableData.length > 1) {
      this.tableData.pop();
      this.refresh();
      this.requestSave();
    } else {
      new import_obsidian.Notice("Cannot remove the last row");
    }
  }
  addColumn() {
    if (this.tableData.length === 0) {
      this.tableData = [["A"]];
    } else {
      this.tableData.forEach((row) => row.push(""));
    }
    this.refresh();
    this.requestSave();
  }
  removeColumn() {
    var _a, _b;
    if (this.tableData.length === 0 || ((_b = (_a = this.tableData[0]) == null ? void 0 : _a.length) != null ? _b : 0) <= 1) {
      new import_obsidian.Notice("Cannot remove the last column");
      return;
    }
    this.tableData.forEach((row) => row.pop());
    this.refresh();
    this.requestSave();
  }
};
var CrudeCSVSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Crude CSV Settings" });
    new import_obsidian.Setting(containerEl).setName("Template path").setDesc("Optional explicit path to a CSV template file, or a folder that contains template.csv").addText(
      (text) => text.setPlaceholder("templates/template.csv or templates/").setValue(this.plugin.settings.templatePath).onChange(async (value) => {
        this.plugin.settings.templatePath = value;
        await this.plugin.saveSettings();
      })
    );
  }
};
